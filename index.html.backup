<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pineapple Knife Bum Adventure</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif; }
    </style>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // Responsive viewport dimensions
        const getViewportDimensions = () => {
          const screenWidth = window.innerWidth;
          const screenHeight = window.innerHeight;
          
          // Mobile-first: use most of the screen, but cap for desktop
          const maxWidth = Math.min(screenWidth - 20, 800);
          const maxHeight = Math.min(screenHeight - 200, 600); // Leave room for UI
          
          return {
            width: maxWidth,
            height: maxHeight
          };
        };
        
        const VIEWPORT_WIDTH = getViewportDimensions().width;
        const VIEWPORT_HEIGHT = getViewportDimensions().height;
        const WORLD_WIDTH = 2400; // 3x wider
        const WORLD_HEIGHT = 1800; // 3x taller
        const CREATURE_SIZE = 60;
        const PLAYER_SIZE = 100;
        const MOVE_SPEED = 1;
        const PLAYER_SPEED = 3;
        const INTERACTION_DISTANCE = 60;
        
        // Tile system constants
        const TILE_SIZE = 128; // Each tile is 128x128 pixels from the 1280x1280 sheet (1280/10=128)
        const TILESHEET_SIZE = 1280;
        const TILES_PER_ROW = 10;
        const WORLD_TILES_X = Math.ceil(WORLD_WIDTH / TILE_SIZE);
        const WORLD_TILES_Y = Math.ceil(WORLD_HEIGHT / TILE_SIZE);
        
        // Tile types mapping (y, x coordinates in tilesheet)
        const TILE_TYPES = {
          GRASS: { x: 0, y: 0, name: 'grass' },
          SEA: { x: 2, y: 0, name: 'sea' },
          PEBBLEBEACH: { x: 1, y: 0, name: 'pebblebeach' },
          ROAD_VERTICAL: { x: 3, y: 0, name: 'road_vertical' },
          ROAD_HORIZONTAL: { x: 4, y: 0, name: 'road_horizontal' },
          ROAD_CROSS: { x: 5, y: 0, name: 'road_cross' }
        };
        
        // Generate tile map for the world - now returns base and overlay layers
        const generateTileMap = () => {
          const baseTileMap = [];
          const overlayTileMap = [];
          
          for (let y = 0; y < WORLD_TILES_Y; y++) {
            const baseRow = [];
            const overlayRow = [];
            
            for (let x = 0; x < WORLD_TILES_X; x++) {
              let baseTile = TILE_TYPES.GRASS; // Always start with grass
              let overlayTile = null; // No overlay by default
              
              // Create some variety in the world
              const worldX = x * TILE_SIZE;
              const worldY = y * TILE_SIZE;
              
              // Add sea around edges (replaces grass entirely)
              if (x === 0 || y === 0 || x === WORLD_TILES_X - 1 || y === WORLD_TILES_Y - 1) {
                baseTile = Math.random() < 0.7 ? TILE_TYPES.SEA : TILE_TYPES.PEBBLEBEACH;
              }
              // Add some random beaches near water (replaces grass entirely)
              else if ((x === 1 || y === 1 || x === WORLD_TILES_X - 2 || y === WORLD_TILES_Y - 2) && Math.random() < 0.5) {
                baseTile = TILE_TYPES.PEBBLEBEACH;
              }
              
              // Add roads as overlays (grass shows through)
              if (x === Math.floor(WORLD_TILES_X / 2)) {
                // Vertical road through middle
                overlayTile = TILE_TYPES.ROAD_VERTICAL;
                if (y === Math.floor(WORLD_TILES_Y / 2)) {
                  overlayTile = TILE_TYPES.ROAD_CROSS; // Crossroads
                }
              }
              else if (y === Math.floor(WORLD_TILES_Y / 2)) {
                // Horizontal road through middle
                overlayTile = TILE_TYPES.ROAD_HORIZONTAL;
              }
              
              baseRow.push(baseTile);
              overlayRow.push(overlayTile);
            }
            baseTileMap.push(baseRow);
            overlayTileMap.push(overlayRow);
          }
          
          return { baseTileMap, overlayTileMap };
        };

        // Game rules: Pineapple beats Bum, Bum beats Knife, Knife beats Pineapple
        const MOVES = {
          PINEAPPLE: 'üçç',
          KNIFE: 'üî™', 
          BUM: 'üçë'
        };

        const MOVE_NAMES = {
          PINEAPPLE: 'Pineapple',
          KNIFE: 'Knife',
          BUM: 'Bum'
        };

        const getWinner = (playerMove, creatureMove) => {
          if (playerMove === creatureMove) return 'tie';
          if (
            (playerMove === 'PINEAPPLE' && creatureMove === 'BUM') ||
            (playerMove === 'BUM' && creatureMove === 'KNIFE') ||
            (playerMove === 'KNIFE' && creatureMove === 'PINEAPPLE')
          ) {
            return 'player';
          }
          return 'creature';
        };

        const getDistance = (obj1, obj2) => {
          const dx = obj1.x - obj2.x;
          const dy = obj1.y - obj2.y;
          return Math.sqrt(dx * dx + dy * dy);
        };

        const generateCreature = (id) => {
          const baseCreatures = [
            { name: 'The Sleepy Bear', src: 'public/art/creature1_SP_The_Sleepy_Bear%20(1).png' },
            { name: 'Gumball', src: 'public/art/creature2_Gumball.png' },
            { name: 'MerCat', src: 'public/art/creature3_MerCat.png' },
            { name: 'Babylamb', src: 'public/art/creature4_Babylamb.png' },
            { name: 'Skullcat', src: 'public/art/creature5_Skullcat.png' }
          ];
          const isShiny = Math.random() < 0.1; // 10% chance for shiny
          const isRare = Math.random() < 0.05; // 5% chance for rare

          let creature = baseCreatures[Math.floor(Math.random() * baseCreatures.length)];
          let rarity = 'common';

          if (isRare) {
            // Super rare creatures - keep some emojis for now or could add rare creature artwork later
            creature = { name: 'Rare_Creature', src: ['ü¶Ñ', 'üê≤', 'ü¶ã', 'üêô'][Math.floor(Math.random() * 4)] };
            rarity = 'rare';
          } else if (isShiny) {
            rarity = 'shiny';
          }
          
          return {
            id,
            name: creature.name,
            src: creature.src,
            rarity,
            x: Math.random() * (WORLD_WIDTH - CREATURE_SIZE),
            y: Math.random() * (WORLD_HEIGHT - CREATURE_SIZE),
            dx: (Math.random() - 0.5) * MOVE_SPEED * 2,
            dy: (Math.random() - 0.5) * MOVE_SPEED * 2,
            wins: 0,
            inParty: false,
            // Animation state
            bounceOffset: 0,
            bouncePhase: Math.random() * Math.PI * 2,
            isPaused: false,
            pauseTimer: 0,
            walkCycle: 0,
            sparklePhase: Math.random() * Math.PI * 2,
            direction: 'down',
            facingLeft: false,
            isSidekick: false
          };
        };

        const generateSidekick = () => {
          const SIDEKICK_SIZE = CREATURE_SIZE * 1.5; // 50% bigger
          return {
            id: 'sidekick-0',
            emoji: 'üë§', // Placeholder, will use custom art
            rarity: 'sidekick',
            x: WORLD_WIDTH / 2 - SIDEKICK_SIZE / 2 - 60,
            y: WORLD_HEIGHT / 2 - SIDEKICK_SIZE / 2,
            dx: 0,
            dy: 0,
            wins: 0,
            inParty: true,
            // Animation state
            bounceOffset: 0,
            bouncePhase: 0,
            isPaused: false,
            pauseTimer: 0,
            walkCycle: 0,
            sparklePhase: 0,
            direction: 'down',
            facingLeft: false,
            isSidekick: true,
            size: SIDEKICK_SIZE
          };
        };

        // Sound effects using Web Audio API
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        const playSound = (type) => {
          if (audioContext.state === 'suspended') {
            audioContext.resume();
          }
          
          const oscillator = audioContext.createOscillator();
          const gainNode = audioContext.createGain();
          
          oscillator.connect(gainNode);
          gainNode.connect(audioContext.destination);
          
          switch(type) {
            case 'battle':
              oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
              oscillator.frequency.exponentialRampToValueAtTime(880, audioContext.currentTime + 0.1);
              gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
              gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
              oscillator.start();
              oscillator.stop(audioContext.currentTime + 0.2);
              break;
              
            case 'win':
              [523, 659, 784].forEach((freq, i) => {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                osc.connect(gain);
                gain.connect(audioContext.destination);
                osc.frequency.setValueAtTime(freq, audioContext.currentTime + i * 0.1);
                gain.gain.setValueAtTime(0.1, audioContext.currentTime + i * 0.1);
                gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + i * 0.1 + 0.3);
                osc.start(audioContext.currentTime + i * 0.1);
                osc.stop(audioContext.currentTime + i * 0.1 + 0.3);
              });
              break;
              
            case 'recruit':
              [392, 523, 659, 784, 1047].forEach((freq, i) => {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                osc.connect(gain);
                gain.connect(audioContext.destination);
                osc.frequency.setValueAtTime(freq, audioContext.currentTime + i * 0.08);
                gain.gain.setValueAtTime(0.08, audioContext.currentTime + i * 0.08);
                gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + i * 0.08 + 0.4);
                osc.start(audioContext.currentTime + i * 0.08);
                osc.stop(audioContext.currentTime + i * 0.08 + 0.4);
              });
              break;
              
            case 'step':
              oscillator.frequency.setValueAtTime(200 + Math.random() * 100, audioContext.currentTime);
              oscillator.type = 'square';
              gainNode.gain.setValueAtTime(0.02, audioContext.currentTime);
              gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);
              oscillator.start();
              oscillator.stop(audioContext.currentTime + 0.1);
              break;
              
            case 'lose':
              oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
              oscillator.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + 0.4);
              gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
              gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
              oscillator.start();
              oscillator.stop(audioContext.currentTime + 0.4);
              break;
          }
        };

        const generateTownElements = () => {
          const elements = [];
          
          // Custom PNG Buildings - using your artwork (doubled size)
          const buildings = [
            { src: 'public/art/building1.png', width: 240, height: 240 },
            { src: 'public/art/building2.png', width: 240, height: 240 },
            { src: 'public/art/building3.png', width: 240, height: 240 },
            { src: 'public/art/building4.png', width: 240, height: 240 },
            { src: 'public/art/building5.png', width: 240, height: 240 },
            { src: 'public/art/buildingpalacepier.png', width: 240, height: 240 }
          ];
          
          // Place each building with better distribution
          const placedBuildings = [];
          
          buildings.forEach((building, i) => {
            const minSpacing = 300; // Minimum distance between buildings (increased for larger buildings)
            let x, y;
            let attempts = 0;
            let validPosition = false;
            
            do {
              // Create zones to better distribute buildings
              const zoneWidth = WORLD_WIDTH / 3;
              const zoneHeight = WORLD_HEIGHT / 2;
              const zoneX = (i % 3) * zoneWidth;
              const zoneY = Math.floor(i / 3) * zoneHeight;
              
              x = zoneX + Math.random() * (zoneWidth - building.width);
              y = zoneY + Math.random() * (zoneHeight - building.height);
              
              // Check distance from other buildings
              validPosition = placedBuildings.every(placed => {
                const dx = x - placed.x;
                const dy = y - placed.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance >= minSpacing;
              });
              
              attempts++;
            } while (!validPosition && attempts < 100);
            
            const buildingData = {
              id: `building-${i}`,
              src: building.src,
              x: x,
              y: y,
              width: building.width,
              height: building.height,
              type: 'building'
            };
            
            elements.push(buildingData);
            placedBuildings.push(buildingData);
          });
          
          
          // Add NPC
          elements.push({
            id: 'npc-quest-giver',
            src: 'public/art/NPC_Mira.png',
            x: WORLD_WIDTH / 2 + 200, // Position to the right of center
            y: WORLD_HEIGHT / 2 - 100, // Slightly above center
            width: 120,
            height: 120,
            type: 'npc'
          });

          // Trees and decorations (keeping these as emojis)
          const decorEmojis = ['üå≥', 'üå≤', 'üå∏', 'üíê', '‚õ≤', 'ü™®'];
          for (let i = 0; i < 25; i++) {
            elements.push({
              id: `decor-${i}`,
              emoji: decorEmojis[Math.floor(Math.random() * decorEmojis.length)],
              x: Math.random() * (WORLD_WIDTH - 40),
              y: Math.random() * (WORLD_HEIGHT - 40),
              width: 40,
              height: 40,
              type: 'decoration'
            });
          }
          return elements;
        };

        // TileRenderer component for rendering individual tiles
        const TileRenderer = ({ tile, x, y }) => {
          const tileX = tile.x * TILE_SIZE;
          const tileY = tile.y * TILE_SIZE;
          
          return (
            <div
              className="absolute"
              style={{
                left: x * TILE_SIZE,
                top: y * TILE_SIZE,
                width: TILE_SIZE,
                height: TILE_SIZE,
                backgroundImage: 'url(public/art/tilesheetpineapple.png)',
                backgroundPosition: `-${tileX}px -${tileY}px`,
                backgroundSize: `${TILESHEET_SIZE}px ${TILESHEET_SIZE}px`,
                imageRendering: 'pixelated'
              }}
            />
          );
        };

        function PineappleKnifeBumGame() {
          const [creatures, setCreatures] = useState([]);
          const [party, setParty] = useState([]);
          const [selectedCreature, setSelectedCreature] = useState(null);
          const [gameState, setGameState] = useState('exploring');
          const [playerMove, setPlayerMove] = useState(null);
          const [creatureMove, setCreatureMove] = useState(null);
          const [countdown, setCountdown] = useState(3);
          const [battleResult, setBattleResult] = useState(null);
          const [creatureWins, setCreatureWins] = useState({});
          const [player, setPlayer] = useState({
            x: WORLD_WIDTH / 2 - PLAYER_SIZE / 2,
            y: WORLD_HEIGHT / 2 - PLAYER_SIZE / 2,
            emoji: 'üßë‚Äçüåæ',
            isMoving: false,
            walkCycle: 0,
            bounceOffset: 0,
            stepCount: 0,
            direction: 'down', // 'left', 'right', 'up', 'down'
            facingLeft: false
          });
          const [camera, setCamera] = useState({
            x: WORLD_WIDTH / 2 - VIEWPORT_WIDTH / 2,
            y: WORLD_HEIGHT / 2 - VIEWPORT_HEIGHT / 2
          });
          const [townElements, setTownElements] = useState([]);
          const [baseTileMap, setBaseTileMap] = useState([]);
          const [overlayTileMap, setOverlayTileMap] = useState([]);
          const [keys, setKeys] = useState({});
          const [nearbyCreature, setNearbyCreature] = useState(null);
          const [currentBattleWins, setCurrentBattleWins] = useState(0);
          const [particles, setParticles] = useState([]);
          const [nearbyNPC, setNearbyNPC] = useState(null);
          const [showNPCDialogue, setShowNPCDialogue] = useState(false);
          const [npcDialogue, setNpcDialogue] = useState('');
          const [battleOptionsReady, setBattleOptionsReady] = useState(false);
          const [selectedBuilding, setSelectedBuilding] = useState(null);
          const [showBuildingModal, setShowBuildingModal] = useState(false);
          const [insideBuilding, setInsideBuilding] = useState(false);
          const [touchControls, setTouchControls] = useState({
            isActive: false,
            startX: 0,
            startY: 0,
            currentX: 0,
            currentY: 0,
            moveX: 0,
            moveY: 0
          });
          const [isMobile, setIsMobile] = useState(false);
          const animationRef = useRef();

          // Particle system
          const createParticles = (x, y, type, count = 10) => {
            const newParticles = [];
            for (let i = 0; i < count; i++) {
              newParticles.push({
                id: Date.now() + i,
                x: x + (Math.random() - 0.5) * 20,
                y: y + (Math.random() - 0.5) * 20,
                vx: (Math.random() - 0.5) * 4,
                vy: (Math.random() - 0.5) * 4 - 2,
                life: 60,
                maxLife: 60,
                type: type,
                emoji: type === 'celebration' ? ['‚ú®', 'üéâ', '‚≠ê', 'üí´'][Math.floor(Math.random() * 4)] : 'üí®'
              });
            }
            setParticles(prev => [...prev, ...newParticles]);
          };

          // Initialize creatures, town, and tile map
          useEffect(() => {
            const initialCreatures = Array.from({ length: 15 }, (_, i) => generateCreature(i));
            const sidekick = generateSidekick();
            
            setCreatures([...initialCreatures, sidekick]);
            setParty([sidekick]);
            setTownElements(generateTownElements());
            
            const { baseTileMap, overlayTileMap } = generateTileMap();
            setBaseTileMap(baseTileMap);
            setOverlayTileMap(overlayTileMap);
            
            // Detect mobile device
            setIsMobile('ontouchstart' in window || navigator.maxTouchPoints > 0);
          }, []);

          // Keyboard event listeners
          useEffect(() => {
            const handleKeyDown = (e) => {
              setKeys(prev => ({ ...prev, [e.key.toLowerCase()]: true }));
              
              // Handle interaction with space or enter
              if ((e.key === ' ' || e.key === 'Enter') && gameState === 'exploring') {
                e.preventDefault();
                if (nearbyCreature) {
                  initiateBattle(nearbyCreature);
                } else if (nearbyNPC) {
                  // Show NPC dialogue
                  const partySize = party.length - 1; // Subtract 1 for Derpy (sidekick doesn't count as recruited friend)
                  if (partySize >= 5) {
                    setNpcDialogue("Perfect! Now that you have 5 friends in your party, we can TAKEDOWN our enemy! The time has come to face our greatest challenge!");
                  } else {
                    setNpcDialogue(`Greetings, Zoe! You currently have ${partySize} recruited friends. When you have 5 friends in your party, we can TAKEDOWN our enemy! Keep battling creatures to recruit more allies.`);
                  }
                  setShowNPCDialogue(true);
              }

              // Handle exit building with Escape key
              if (e.key === 'Escape' && insideBuilding) {
                exitBuilding();
              }
            };

            const handleKeyUp = (e) => {
              setKeys(prev => ({ ...prev, [e.key.toLowerCase()]: false }));
            };

            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('keyup', handleKeyUp);

            return () => {
              window.removeEventListener('keydown', handleKeyDown);
              window.removeEventListener('keyup', handleKeyUp);
            };
          }, [nearbyCreature, gameState]);

          // Simplified touch controls for mobile movement
          const handleViewportTouchStart = (e) => {
            if (!isMobile || gameState !== 'exploring') return;
            
            const touch = e.touches[0];
            setTouchControls(prev => ({
              ...prev,
              isActive: true,
              startX: touch.clientX,
              startY: touch.clientY,
              currentX: touch.clientX,
              currentY: touch.clientY
            }));
          };

          const handleViewportTouchMove = (e) => {
            if (!isMobile || !touchControls.isActive) return;
            e.preventDefault();
            const touch = e.touches[0];
            
            const deltaX = touch.clientX - touchControls.startX;
            const deltaY = touch.clientY - touchControls.startY;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            
            // Normalize movement (max distance = 50px)
            const maxDistance = 50;
            const normalizedDistance = Math.min(distance, maxDistance) / maxDistance;
            
            setTouchControls(prev => ({
              ...prev,
              currentX: touch.clientX,
              currentY: touch.clientY,
              moveX: (deltaX / maxDistance) * normalizedDistance,
              moveY: (deltaY / maxDistance) * normalizedDistance
            }));
          };

          const handleViewportTouchEnd = (e) => {
            if (!isMobile) return;
            setTouchControls(prev => ({
              ...prev,
              isActive: false,
              moveX: 0,
              moveY: 0
            }));
          };

          // Unified battle initiation function
          const initiateBattle = (creature) => {
            if (creature.inParty || gameState !== 'exploring') return;
            
            console.log('Initiating battle with:', creature.name, creature.id);
            playSound('battle');
            setSelectedCreature(creature);
            setCurrentBattleWins(creatureWins[creature.id] || 0);
            setGameState('battling');
            setPlayerMove(null);
            setBattleResult(null);
            setBattleOptionsReady(false);
            
            // Add delay before showing battle options to prevent accidental taps
            setTimeout(() => {
              setBattleOptionsReady(true);
            }, 800); // 800ms delay
          };

          // New building interaction functions
          const handleBuildingClick = (building) => {
            setSelectedBuilding(building);
            setShowBuildingModal(true);
          };

          const confirmEnterBuilding = () => {
            setShowBuildingModal(false);
            setInsideBuilding(true);

            // Move player and party to building interior positions
            const interiorStartX = 150;
            const interiorStartY = 150;

            setPlayer(prev => ({
              ...prev,
              x: interiorStartX,
              y: interiorStartY
            }));

            // Position party members near player in the interior
            setCreatures(prev => prev.map(creature => {
              if (creature.inParty) {
                const offsetX = creature.isSidekick ? -60 : (-80 - ((creature.id % 100) * 30));
                return {
                  ...creature,
                  x: interiorStartX + offsetX,
                  y: interiorStartY
                };
              }
              return creature;
            }));
          };

          const exitBuilding = () => {
            setInsideBuilding(false);
            setSelectedBuilding(null);

            // Move player back to world center (simple approach)
            setPlayer(prev => ({
              ...prev,
              x: WORLD_WIDTH / 2,
              y: WORLD_HEIGHT / 2
            }));
          };

          // Animation loop for player and creature movement
          useEffect(() => {
            const animate = () => {
              if (gameState === 'exploring') {
                // Update player position
                setPlayer(prev => {
                  let newX = prev.x;
                  let newY = prev.y;
                  let isMoving = false;
                  let newDirection = prev.direction;
                  let newFacingLeft = prev.facingLeft;

                  // Keyboard controls
                  if (keys['w'] || keys['arrowup']) {
                    newY -= PLAYER_SPEED;
                    isMoving = true;
                    newDirection = 'up';
                  }
                  if (keys['s'] || keys['arrowdown']) {
                    newY += PLAYER_SPEED;
                    isMoving = true;
                    newDirection = 'down';
                  }
                  if (keys['a'] || keys['arrowleft']) {
                    newX -= PLAYER_SPEED;
                    isMoving = true;
                    newDirection = 'left';
                    newFacingLeft = false;
                  }
                  if (keys['d'] || keys['arrowright']) {
                    newX += PLAYER_SPEED;
                    isMoving = true;
                    newDirection = 'right';
                    newFacingLeft = true;
                  }

                  // Touch controls
                  if (touchControls.isActive) {
                    const moveX = touchControls.moveX * PLAYER_SPEED * 0.8;
                    const moveY = touchControls.moveY * PLAYER_SPEED * 0.8;
                    newX += moveX;
                    newY += moveY;
                    
                    if (Math.abs(touchControls.moveX) > 0.1 || Math.abs(touchControls.moveY) > 0.1) {
                      isMoving = true;
                      
                      // Determine direction based on touch movement
                      if (Math.abs(moveX) > Math.abs(moveY)) {
                        // Horizontal movement is dominant
                        if (moveX > 0) {
                          newDirection = 'right';
                          newFacingLeft = true;
                        } else {
                          newDirection = 'left';
                          newFacingLeft = false;
                        }
                      } else {
                        // Vertical movement is dominant
                        if (moveY > 0) {
                          newDirection = 'down';
                        } else {
                          newDirection = 'up';
                        }
                      }
                    }
                  }

                  // Keep player within bounds (world or building interior)
                  if (insideBuilding) {
                    // Building interior bounds (small square room)
                    const INTERIOR_SIZE = 400;
                    newX = Math.max(50, Math.min(INTERIOR_SIZE - PLAYER_SIZE, newX));
                    newY = Math.max(50, Math.min(INTERIOR_SIZE - PLAYER_SIZE, newY));
                  } else {
                    // Normal world bounds
                    newX = Math.max(0, Math.min(WORLD_WIDTH - PLAYER_SIZE, newX));
                    newY = Math.max(0, Math.min(WORLD_HEIGHT - PLAYER_SIZE, newY));
                  }

                  // Update walking animation (smoother for player)
                  let newWalkCycle = prev.walkCycle;
                  let newBounceOffset = 0;
                  let newStepCount = prev.stepCount;
                  
                  if (isMoving) {
                    newWalkCycle += 0.2;
                    newBounceOffset = Math.sin(newWalkCycle) * 1.5;
                    newStepCount++;
                    
                    // Play step sound every 20 frames (~3 times per second)
                    if (newStepCount % 20 === 0) {
                      playSound('step');
                    }
                  }

                  return { 
                    ...prev, 
                    x: newX, 
                    y: newY, 
                    isMoving, 
                    walkCycle: newWalkCycle,
                    bounceOffset: newBounceOffset,
                    stepCount: newStepCount,
                    direction: newDirection,
                    facingLeft: newFacingLeft
                  };
                });

                // Update camera to follow player
                setCamera(prev => {
                  if (insideBuilding) {
                    // Fixed camera position for building interior
                    return { x: 0, y: 0 };
                  } else {
                    // Normal camera following for outside world
                    const targetX = player.x - VIEWPORT_WIDTH / 2 + PLAYER_SIZE / 2;
                    const targetY = player.y - VIEWPORT_HEIGHT / 2 + PLAYER_SIZE / 2;
                    
                    // Keep camera within world bounds
                    const clampedX = Math.max(0, Math.min(WORLD_WIDTH - VIEWPORT_WIDTH, targetX));
                    const clampedY = Math.max(0, Math.min(WORLD_HEIGHT - VIEWPORT_HEIGHT, targetY));
                    
                    // Smooth camera movement
                    const smoothFactor = 0.1;
                    const newX = prev.x + (clampedX - prev.x) * smoothFactor;
                    const newY = prev.y + (clampedY - prev.y) * smoothFactor;
                    
                    return { x: newX, y: newY };
                  }
                });

                // Update creatures
                setCreatures(prev => {
                  const updatedCreatures = prev.map(creature => {
                    if (creature.inParty) {
                      // Make party creatures follow the player
                      const offsetX = creature.isSidekick ? -60 : (-80 - ((creature.id % 100) * 30));
                      const targetX = player.x + offsetX;
                      const targetY = player.y;
                      const dx = targetX - creature.x;
                      const dy = targetY - creature.y;
                      const distance = Math.sqrt(dx * dx + dy * dy);
                      
                      let newDirection = creature.direction;
                      let newFacingLeft = creature.facingLeft;
                      
                      if (distance > 5) {
                        const moveX = (dx / distance) * PLAYER_SPEED * 0.8;
                        const moveY = (dy / distance) * PLAYER_SPEED * 0.8;
                        
                        // Update direction based on movement
                        if (Math.abs(moveX) > Math.abs(moveY)) {
                          if (moveX > 0) {
                            newDirection = 'right';
                            newFacingLeft = true;
                          } else {
                            newDirection = 'left';
                            newFacingLeft = false;
                          }
                        } else {
                          if (moveY > 0) {
                            newDirection = 'down';
                          } else {
                            newDirection = 'up';
                          }
                        }
                        
                        return { 
                          ...creature, 
                          x: creature.x + moveX, 
                          y: creature.y + moveY,
                          direction: newDirection,
                          facingLeft: newFacingLeft
                        };
                      }
                      return creature;
                    } else {
                      // Normal creature movement with walking animation
                      let newX = creature.x;
                      let newY = creature.y;
                      let newDx = creature.dx;
                      let newDy = creature.dy;
                      let newIsPaused = creature.isPaused;
                      let newPauseTimer = creature.pauseTimer;
                      let newBouncePhase = creature.bouncePhase;
                      let newBounceOffset = creature.bounceOffset;
                      let newWalkCycle = creature.walkCycle;

                      // Handle pausing behavior
                      if (creature.isPaused) {
                        newPauseTimer--;
                        if (newPauseTimer <= 0) {
                          newIsPaused = false;
                          // Sometimes change direction after pause
                          if (Math.random() < 0.3) {
                            newDx = (Math.random() - 0.5) * MOVE_SPEED * 2;
                            newDy = (Math.random() - 0.5) * MOVE_SPEED * 2;
                          }
                        }
                        newBounceOffset = 0; // No bounce when paused
                      } else {
                        // Random chance to pause
                        if (Math.random() < 0.003) { // 0.3% chance per frame
                          newIsPaused = true;
                          newPauseTimer = 60 + Math.random() * 120; // 1-3 seconds at 60fps
                        } else {
                          // Normal movement
                          newX = creature.x + newDx;
                          newY = creature.y + newDy;

                          // Bounce off walls
                          if (newX <= 0 || newX >= WORLD_WIDTH - CREATURE_SIZE) {
                            newDx = -newDx;
                            newX = Math.max(0, Math.min(WORLD_WIDTH - CREATURE_SIZE, newX));
                          }
                          if (newY <= 0 || newY >= WORLD_HEIGHT - CREATURE_SIZE) {
                            newDy = -newDy;
                            newY = Math.max(0, Math.min(WORLD_HEIGHT - CREATURE_SIZE, newY));
                          }

                          // Update walking animation (slower, smoother)
                          newWalkCycle += 0.15;
                          newBouncePhase += 0.25;
                          
                          // Create bouncy motion (sine wave for vertical offset)
                          const speed = Math.sqrt(newDx * newDx + newDy * newDy);
                          if (speed > 0.1) {
                            newBounceOffset = Math.sin(newBouncePhase) * 2; // Reduced bounce height
                          } else {
                            newBounceOffset = 0;
                          }
                        }
                      }

                      // Update sparkle animation for shiny/rare creatures
                      let newSparklePhase = creature.sparklePhase || 0;
                      if (creature.rarity === 'shiny' || creature.rarity === 'rare') {
                        newSparklePhase += 0.1;
                      }

                      return { 
                        ...creature, 
                        x: newX, 
                        y: newY, 
                        dx: newDx, 
                        dy: newDy,
                        bounceOffset: newBounceOffset,
                        bouncePhase: newBouncePhase,
                        isPaused: newIsPaused,
                        pauseTimer: newPauseTimer,
                        walkCycle: newWalkCycle,
                        sparklePhase: newSparklePhase
                      };
                    }
                  });

                  // Check for nearby creatures for interaction
                  const nearby = updatedCreatures.find(creature => 
                    !creature.inParty && getDistance(player, creature) < INTERACTION_DISTANCE
                  );
                  setNearbyCreature(nearby || null);

                  // Check for nearby NPC
                  const nearbyNPCElement = townElements.find(element => 
                    element.type === 'npc' && getDistance(player, element) < INTERACTION_DISTANCE
                  );
                  setNearbyNPC(nearbyNPCElement || null);


                  return updatedCreatures;
                });

                // Update particles
                setParticles(prev => {
                  return prev.map(particle => {
                    const newParticle = {
                      ...particle,
                      x: particle.x + particle.vx,
                      y: particle.y + particle.vy,
                      vy: particle.vy + 0.1, // gravity
                      life: particle.life - 1
                    };
                    return newParticle;
                  }).filter(particle => particle.life > 0);
                });
              }
              animationRef.current = requestAnimationFrame(animate);
            };

            animationRef.current = requestAnimationFrame(animate);
            return () => {
              if (animationRef.current) {
                cancelAnimationFrame(animationRef.current);
              }
            };
          }, [gameState, keys, player, insideBuilding]);

          const handlePlayerMove = (move) => {
            setPlayerMove(move);
            const moves = Object.keys(MOVES);
            const randomMove = moves[Math.floor(Math.random() * moves.length)];
            setCreatureMove(randomMove);
            
            setGameState('countdown');
            setCountdown(3);
          };

          // Countdown effect
          useEffect(() => {
            if (gameState === 'countdown' && countdown > 0) {
              const timer = setTimeout(() => {
                setCountdown(countdown - 1);
              }, 1000);
              return () => clearTimeout(timer);
            } else if (gameState === 'countdown' && countdown === 0) {
              setGameState('revealing');
              
              // Show result after a brief delay
              setTimeout(() => {
                const result = getWinner(playerMove, creatureMove);
                setBattleResult(result);
                
                if (result === 'player') {
                  playSound('win');
                  const currentWins = creatureWins[selectedCreature.id] || 0;
                  const newWins = currentWins + 1;
                  setCurrentBattleWins(newWins);
                  setCreatureWins(prev => ({ ...prev, [selectedCreature.id]: newWins }));
                  
                  if (newWins >= 3) {
                    // Creature joins party
                    setTimeout(() => playSound('recruit'), 800);
                    setTimeout(() => createParticles(selectedCreature.x + CREATURE_SIZE/2, selectedCreature.y + CREATURE_SIZE/2, 'celebration', 15), 800);
                    setCreatures(prev => prev.map(c => 
                      c.id === selectedCreature.id ? { ...c, inParty: true } : c
                    ));
                    setParty(prev => [...prev, selectedCreature]);
                    setTimeout(() => {
                      setGameState('exploring');
                      setSelectedCreature(null);
                      setBattleResult(null);
                      setPlayerMove(null);
                      setCreatureMove(null);
                      setCurrentBattleWins(0);
                    }, 3000);
                  } else {
                    setTimeout(() => {
                      setGameState('exploring');
                      setSelectedCreature(null);
                      setBattleResult(null);
                      setPlayerMove(null);
                      setCreatureMove(null);
                      setCurrentBattleWins(0);
                    }, 2500);
                  }
                } else {
                  playSound('lose');
                  setTimeout(() => {
                    setGameState('exploring');
                    setSelectedCreature(null);
                    setBattleResult(null);
                    setPlayerMove(null);
                    setCreatureMove(null);
                    setCurrentBattleWins(0);
                  }, 2500);
                }
              }, 1000);
            }
          }, [gameState, countdown, playerMove, creatureMove, selectedCreature, creatureWins]);

          const resetGame = () => {
            const initialCreatures = Array.from({ length: 15 }, (_, i) => generateCreature(i));
            const sidekick = generateSidekick();
            
            setCreatures([...initialCreatures, sidekick]);
            setParty([sidekick]);
            setCreatureWins({});
            setGameState('exploring');
            setSelectedCreature(null);
            setBattleResult(null);
            setCurrentBattleWins(0);
            const newPlayer = {
              x: WORLD_WIDTH / 2 - PLAYER_SIZE / 2,
              y: WORLD_HEIGHT / 2 - PLAYER_SIZE / 2,
              emoji: 'üßë‚Äçüåæ',
              isMoving: false,
              walkCycle: 0,
              bounceOffset: 0,
              stepCount: 0,
              direction: 'down',
              facingLeft: false
            };
            setPlayer(newPlayer);
            setCamera({
              x: WORLD_WIDTH / 2 - VIEWPORT_WIDTH / 2,
              y: WORLD_HEIGHT / 2 - VIEWPORT_HEIGHT / 2
            });
            setTownElements(generateTownElements());
            
            const { baseTileMap, overlayTileMap } = generateTileMap();
            setBaseTileMap(baseTileMap);
            setOverlayTileMap(overlayTileMap);
            
            setNearbyCreature(null);
          };

          return (
            <div className="w-full min-h-screen bg-green-100 flex flex-col">
              {/* Header - Compact for mobile */}
              <div className="text-center p-2 bg-green-200 shadow-sm">
                <div className="flex items-center justify-center mb-2">
                  <img 
                    src="public/art/logo.png" 
                    alt="Game Logo" 
                    className="h-32 sm:h-48 object-contain"
                    style={{ imageRendering: 'pixelated' }}
                  />
                </div>
                <div className="text-sm sm:text-lg text-green-700">
                  Zoe's Party: {party.length} | üçç‚Üíüçë üçë‚Üíüî™ üî™‚Üíüçç
                </div>
              </div>

              {/* Game Viewport */}
              {insideBuilding ? (
                <div className="flex-1 flex items-center justify-center p-2">
                  <div className="bg-amber-100 border-4 border-amber-600 rounded-lg p-8 max-w-md shadow-xl text-center">
                    <h2 className="text-2xl font-bold text-amber-800 mb-4">Building Interior</h2>
                    <div className="w-full h-32 bg-gradient-to-b from-amber-200 to-amber-300 rounded-lg mb-4 flex items-center justify-center">
                      <span className="text-4xl">üè†</span>
                    </div>
                    <p className="text-amber-800 text-lg mb-6">
                      This is a cozy interior space. You can explore and rest here.
                    </p>
                    <button
                      onClick={exitBuilding}
                      className="bg-red-500 hover:bg-red-600 text-white px-8 py-4 rounded-lg text-lg font-bold transition-colors min-h-[60px]"
                    >
                      Exit Building
                    </button>
                  </div>
                </div>
              ) : (
                <div className="flex-1 flex items-center justify-center p-2">
                  <div
                    className="relative bg-green-200 border-4 border-green-600 overflow-hidden touch-none"
                    style={{
                      width: VIEWPORT_WIDTH,
                      height: VIEWPORT_HEIGHT,
                      maxWidth: '100vw',
                      maxHeight: '70vh'
                    }}
                    onTouchStart={isMobile ? handleViewportTouchStart : undefined}
                    onTouchMove={isMobile ? handleViewportTouchMove : undefined}
                    onTouchEnd={isMobile ? handleViewportTouchEnd : undefined}
                  >
                  {/* World Container */}
                  <div
                    className="absolute"
                    style={{
                      width: WORLD_WIDTH,
                      height: WORLD_HEIGHT,
                      left: -camera.x,
                      top: -camera.y
                    }}
                  >
                  {/* Base tiles (grass, sea, beach) */}
                  {baseTileMap.map((row, y) => 
                    row.map((tile, x) => (
                      <TileRenderer 
                        key={`base-${x}-${y}`} 
                        tile={tile} 
                        x={x} 
                        y={y} 
                      />
                    ))
                  )}
                  
                  {/* Overlay tiles (roads with transparent backgrounds) */}
                  {overlayTileMap.map((row, y) => 
                    row.map((tile, x) => 
                      tile ? (
                        <TileRenderer 
                          key={`overlay-${x}-${y}`} 
                          tile={tile} 
                          x={x} 
                          y={y} 
                        />
                      ) : null
                    )
                  )}
                
                  {/* Town Elements */}
                  {townElements.map(element => (
                    <div
                      key={element.id}
                      className="absolute"
                      style={{
                        left: element.x,
                        top: element.y,
                        width: element.width,
                        height: element.height,
                        zIndex: element.type === 'building' ? 2 : 1
                      }}
                    >
                      {element.type === 'building' ? (
                        <div
                          className="w-full h-full cursor-pointer hover:opacity-80 transform hover:scale-105 transition-all duration-200"
                          onClick={() => handleBuildingClick(element)}
                          onTouchEnd={(e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            handleBuildingClick(element);
                          }}
                          style={{
                            touchAction: 'manipulation',
                            userSelect: 'none'
                          }}
                        >
                          <img
                            src={element.src}
                            alt={`Building ${element.id}`}
                            className="w-full h-full object-contain"
                            style={{
                              imageRendering: 'pixelated' // For crisp pixel art if needed
                            }}
                          />
                        </div>
                      ) : element.type === 'npc' ? (
                        <div 
                          className={`transition-all duration-200 ${
                            nearbyNPC?.id === element.id ? 'animate-bounce scale-110' : ''
                          } ${isMobile ? 'cursor-pointer touch-manipulation select-none' : 'cursor-pointer'}`}
                          style={{
                            width: element.width + (isMobile ? 20 : 0), // Bigger touch target on mobile
                            height: element.height + (isMobile ? 20 : 0),
                            padding: isMobile ? '10px' : '0', // Extra padding for easier tapping
                            margin: isMobile ? '-10px' : '0',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center'
                          }}
                          onClick={!isMobile ? () => {
                            const partySize = party.length - 1;
                            if (partySize >= 5) {
                              setNpcDialogue("Perfect! Now that you have 5 friends in your party, we can TAKEDOWN our enemy! The time has come to face our greatest challenge!");
                            } else {
                              setNpcDialogue(`Greetings, Zoe! You currently have ${partySize} recruited friends. When you have 5 friends in your party, we can TAKEDOWN our enemy! Keep battling creatures to recruit more allies.`);
                            }
                            setShowNPCDialogue(true);
                          } : undefined}
                          onPointerDown={isMobile ? (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            const partySize = party.length - 1;
                            if (partySize >= 5) {
                              setNpcDialogue("Perfect! Now that you have 5 friends in your party, we can TAKEDOWN our enemy! The time has come to face our greatest challenge!");
                            } else {
                              setNpcDialogue(`Greetings, Zoe! You currently have ${partySize} recruited friends. When you have 5 friends in your party, we can TAKEDOWN our enemy! Keep battling creatures to recruit more allies.`);
                            }
                            setShowNPCDialogue(true);
                          } : undefined}
                        >
                          <img
                            src={element.src}
                            alt="Mira"
                            className="w-full h-full object-contain"
                            style={{
                              imageRendering: 'pixelated'
                            }}
                          />
                        </div>
                      ) : (
                        <div className="text-4xl">
                          {element.emoji}
                        </div>
                      )}
                    </div>
                  ))}
                  </>
                  )}

                  {/* Non-party Creatures in blurred background when inside building */}
                  {insideBuilding && creatures.filter(creature => !creature.inParty).map(creature => (
                    <div
                      key={`bg-${creature.id}`}
                      className="absolute text-3xl opacity-50"
                      style={{
                        left: creature.x,
                        top: creature.y + (creature.bounceOffset || 0),
                        width: creature.size || CREATURE_SIZE,
                        height: creature.size || CREATURE_SIZE,
                        zIndex: 3
                      }}
                    >
                      {creature.isSidekick ? (
                        <img
                          src={creature.direction === 'up' ? 'public/art/sidekickback.png' : 'public/art/sidekickfront.png'}
                          alt="Derpy"
                          className="w-full h-full object-contain"
                          style={{
                            imageRendering: 'pixelated',
                            transform: creature.facingLeft ? 'scaleX(-1)' : 'scaleX(1)'
                          }}
                        />
                      ) : (
                        rarity === 'rare' && typeof creature.src === 'string' && creature.src.includes('ü¶Ñ') ? (
                          creature.src
                        ) : (
                          <img
                            src={creature.src}
                            alt={creature.name}
                            className="w-full h-full object-contain"
                            style={{
                              imageRendering: 'pixelated',
                              transform: creature.facingLeft ? 'scaleX(-1)' : 'scaleX(1)'
                            }}
                          />
                        )
                      )}
                    </div>
                  ))}
                </div>
              )}

              {/* Regular World Content (when not inside building) OR Party creatures (always visible) */}
              <div className="absolute" style={{
                width: insideBuilding ? VIEWPORT_WIDTH : WORLD_WIDTH,
                height: insideBuilding ? VIEWPORT_HEIGHT : WORLD_HEIGHT,
                left: insideBuilding ? 0 : -camera.x,
                top: insideBuilding ? 0 : -camera.y,
                zIndex: insideBuilding ? 40 : 1
              }}>
                {/* All Creatures (non-party only when outside, party always visible) */}
                {creatures.filter(creature => !insideBuilding || creature.inParty).map(creature => {
                    const isNearby = nearbyCreature?.id === creature.id;
                    const canInteract = !creature.inParty && (isNearby || isMobile);
                    
                    return (
                    <div
                      key={creature.id}
                      className={`absolute text-3xl transition-all duration-100 ease-out ${
                        creature.inParty && !creature.isSidekick ? 'opacity-70' : ''
                      } ${selectedCreature?.id === creature.id ? 'animate-pulse' : ''} ${
                        isNearby ? 'scale-110 animate-pulse' : ''
                      } ${creature.isPaused ? 'opacity-80' : ''} ${
                        creature.rarity === 'shiny' ? 'drop-shadow-lg' : ''
                      } ${creature.rarity === 'rare' ? 'drop-shadow-xl' : ''} ${
                        canInteract && isMobile ? 'cursor-pointer' : ''
                      } ${!creature.inParty && gameState === 'exploring' ? 'touch-manipulation select-none' : ''}`}
                      style={{
                        left: creature.x,
                        top: creature.y + (creature.bounceOffset || 0),
                        width: (creature.size || CREATURE_SIZE) + (isMobile ? 20 : 0), // Bigger touch target on mobile
                        height: (creature.size || CREATURE_SIZE) + (isMobile ? 20 : 0),
                        zIndex: creature.rarity === 'rare' ? 8 : (creature.rarity === 'shiny' ? 7 : (creature.isSidekick ? 6 : 5)),
                        transform: creature.isPaused ? 'none' : `scale(${1 + Math.sin(creature.walkCycle || 0) * 0.03})`,
                        filter: creature.isPaused ? 'brightness(0.9)' : 
                               creature.rarity === 'rare' ? 'brightness(1.3) drop-shadow(0 0 8px gold)' :
                               creature.rarity === 'shiny' ? 'brightness(1.1) drop-shadow(0 0 4px silver)' : 'none',
                        padding: isMobile ? '10px' : '0', // Extra padding for easier tapping
                        margin: isMobile ? '-10px' : '0'
                      }}
                      onClick={!creature.inParty && gameState === 'exploring' && !isMobile ? () => initiateBattle(creature) : undefined}
                      onPointerDown={!creature.inParty && isMobile && gameState === 'exploring' ? (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        initiateBattle(creature);
                      } : undefined}
                    >
                      {creature.isSidekick ? (
                        <img
                          src={creature.direction === 'up' ? 'public/art/sidekickback.png' : 'public/art/sidekickfront.png'}
                          alt="Derpy"
                          className="w-full h-full object-contain"
                          style={{
                            imageRendering: 'pixelated',
                            transform: creature.facingLeft ? 'scaleX(-1)' : 'scaleX(1)'
                          }}
                        />
                      ) : (
                        creature.rarity === 'rare' && typeof creature.src === 'string' && creature.src.includes('ü¶Ñ') ? (
                          creature.src
                        ) : (
                          <img
                            src={creature.src}
                            alt={creature.name}
                            className="w-full h-full object-contain"
                            style={{
                              imageRendering: 'pixelated',
                              transform: creature.facingLeft ? 'scaleX(-1)' : 'scaleX(1)'
                            }}
                          />
                        )
                      )}

                      {/* Sparkle effects for special creatures */}
                      {(creature.rarity === 'shiny' || creature.rarity === 'rare') && (
                        <>
                          <div 
                            className="absolute text-xs pointer-events-none"
                            style={{
                              left: -5 + Math.sin(creature.sparklePhase) * 8,
                              top: -5 + Math.cos(creature.sparklePhase * 1.3) * 8,
                              opacity: 0.5 + Math.sin(creature.sparklePhase * 2) * 0.3
                            }}
                          >
                            ‚ú®
                          </div>
                          <div 
                            className="absolute text-xs pointer-events-none"
                            style={{
                              right: -5 + Math.cos(creature.sparklePhase * 0.8) * 6,
                              bottom: -5 + Math.sin(creature.sparklePhase * 1.5) * 6,
                              opacity: 0.5 + Math.cos(creature.sparklePhase * 1.8) * 0.3
                            }}
                          >
                            ‚≠ê
                          </div>
                          {creature.rarity === 'rare' && (
                            <div 
                              className="absolute text-xs pointer-events-none"
                              style={{
                                left: 15 + Math.sin(creature.sparklePhase * 1.2) * 5,
                                top: 20 + Math.cos(creature.sparklePhase * 0.9) * 5,
                                opacity: 0.6 + Math.sin(creature.sparklePhase * 2.5) * 0.2
                              }}
                            >
                              üí´
                            </div>
                          )}
                        </>
                      )}
                      
                      {/* Rarity indicator */}
                      {creature.rarity !== 'common' && (
                        <div className={`absolute -top-1 -left-1 text-xs ${
                          creature.rarity === 'rare' ? 'text-yellow-400' : 'text-gray-300'
                        }`}>
                          {creature.rarity === 'rare' ? 'üëë' : '‚≠ê'}
                        </div>
                      )}
                      
                      {creature.isPaused && (
                        <div className="absolute -top-3 left-1/2 transform -translate-x-1/2">
                          <div className="text-xs opacity-60">üí§</div>
                        </div>
                      )}
                      {creatureWins[creature.id] > 0 && (
                        <div className="absolute -top-2 -right-2 bg-yellow-400 text-xs rounded-full w-5 h-5 flex items-center justify-center">
                          {creatureWins[creature.id]}
                        </div>
                      )}
                    </div>
                    );
                  })}

                  {/* Player Character */}
                  <div
                    className="absolute z-10 transition-all duration-100 ease-out"
                    style={{
                      left: player.x,
                      top: player.y + (player.bounceOffset || 0),
                      width: PLAYER_SIZE,
                      height: PLAYER_SIZE,
                      zIndex: 10,
                      transform: `${player.isMoving ? `scale(${1 + Math.sin(player.walkCycle || 0) * 0.02})` : 'scale(1)'} ${player.facingLeft ? 'scaleX(-1)' : 'scaleX(1)'}`
                    }}
                  >
                    <img
                      src={player.direction === 'up' ? 'public/art/playercharacterback.png' : 'public/art/playercharacter.png'}
                      alt="Zoe"
                      className="w-full h-full object-contain"
                      style={{
                        imageRendering: 'pixelated'
                      }}
                    />
                  </div>

                  {/* Interaction Indicator */}
                  {nearbyCreature && (
                    <div
                      className={`absolute z-20 ${isMobile ? 'cursor-pointer' : 'pointer-events-none'}`}
                      style={{
                        left: (nearbyCreature.x - camera.x) + CREATURE_SIZE / 2 - 30,
                        top: (nearbyCreature.y - camera.y) - 45,
                        width: 60,
                        height: 40,
                        zIndex: 20
                      }}
                      onClick={isMobile ? () => initiateBattle(nearbyCreature) : undefined}
                    >
                      <div className={`bg-blue-500 text-white border-2 border-blue-600 rounded px-2 py-1 text-sm font-bold text-center animate-bounce shadow-lg ${
                        isMobile ? 'min-h-[30px] min-w-[50px] flex items-center justify-center touch-manipulation' : ''
                      }`}>
                        {isMobile ? 'TAP' : 'SPACE'}
                      </div>
                    </div>
                  )}

                  {/* NPC Interaction Indicator */}
                  {nearbyNPC && !insideBuilding && (
                    <div
                      className={`absolute z-20 ${isMobile ? 'cursor-pointer' : 'pointer-events-none'}`}
                      style={{
                        left: (nearbyNPC.x - camera.x) + nearbyNPC.width / 2 - 30,
                        top: (nearbyNPC.y - camera.y) - 45,
                        width: 60,
                        height: 40,
                        zIndex: 20
                      }}
                      onClick={isMobile ? () => {
                        const partySize = party.length - 1;
                        if (partySize >= 5) {
                          setNpcDialogue("Perfect! Now that you have 5 friends in your party, we can TAKEDOWN our enemy! The time has come to face our greatest challenge!");
                        } else {
                          setNpcDialogue(`Greetings, Zoe! You currently have ${partySize} recruited friends. When you have 5 friends in your party, we can TAKEDOWN our enemy! Keep battling creatures to recruit more allies.`);
                        }
                        setShowNPCDialogue(true);
                      } : undefined}
                    >
                      <div className={`bg-green-500 text-white border-2 border-green-600 rounded px-2 py-1 text-sm font-bold text-center animate-bounce shadow-lg ${
                        isMobile ? 'min-h-[30px] min-w-[50px] flex items-center justify-center touch-manipulation' : ''
                      }`}>
                        {isMobile ? 'TAP' : 'TALK'}
                      </div>
                    </div>
                  )}


                  {/* Particles */}
                  {particles.map(particle => (
                    <div
                      key={particle.id}
                      className="absolute pointer-events-none text-lg"
                      style={{
                        left: particle.x,
                        top: particle.y,
                        opacity: particle.life / particle.maxLife,
                        transform: `scale(${particle.life / particle.maxLife})`,
                        zIndex: 25
                      }}
                    >
                      {particle.emoji}
                    </div>
                  ))}
                </div>

                {/* Party creatures display */}
                {party.length > 0 && (
                  <div className="absolute top-2 left-2 bg-white bg-opacity-90 p-2 sm:p-3 rounded-lg text-xs sm:text-sm shadow-lg">
                    <div className="font-bold text-green-800 mb-2">Zoe's Party:</div>
                    <div className="flex flex-col gap-2">
                      {party.map(creature => (
                        <div key={creature.id} className="flex items-center gap-2">
                          {creature.isSidekick ? (
                            <>
                              <img
                                src="public/art/sidekickfront.png"
                                alt="Derpy"
                                className="w-6 h-6 sm:w-8 sm:h-8 object-contain"
                                style={{ imageRendering: 'pixelated' }}
                              />
                              <span className="text-xs sm:text-sm font-medium text-green-700">Derpy</span>
                            </>
                          ) : (
                            <>
                              {creature.rarity === 'rare' && typeof creature.src === 'string' && creature.src.includes('ü¶Ñ') ? (
                                <span className="text-lg sm:text-xl">{creature.src}</span>
                              ) : (
                                <img
                                  src={creature.src}
                                  alt={creature.name}
                                  className="w-6 h-6 sm:w-8 sm:h-8 object-contain"
                                  style={{ imageRendering: 'pixelated' }}
                                />
                              )}
                              <span className="text-xs sm:text-sm text-green-700">{creature.name}</span>
                            </>
                          )}
                        </div>
                      ))}
                    </div>
                  </div>
                )}

                {/* Virtual Joystick for Mobile */}
                {isMobile && touchControls.isActive && (
                  <>
                    {/* Joystick Base */}
                    <div 
                      className="absolute w-16 h-16 bg-white bg-opacity-30 border-2 border-white rounded-full pointer-events-none"
                      style={{
                        left: touchControls.startX - 32,
                        top: touchControls.startY - 32
                      }}
                    />
                    {/* Joystick Knob */}
                    <div 
                      className="absolute w-6 h-6 bg-white bg-opacity-80 rounded-full pointer-events-none"
                      style={{
                        left: touchControls.startX + touchControls.moveX * 25 - 12,
                        top: touchControls.startY + touchControls.moveY * 25 - 12
                      }}
                    />
                  </>
                )}
                  </div>
                </div>
              )}

              {/* NPC Dialogue Modal */}
              {showNPCDialogue && (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
                  <div className="bg-white p-4 sm:p-6 rounded-xl border-4 border-green-600 max-w-sm sm:max-w-md w-full shadow-2xl">
                    <div className="text-center">
                      <div className="mb-4">
                        <img 
                          src="public/art/NPC_Mira.png" 
                          alt="Mira" 
                          className="w-16 h-16 mx-auto object-contain"
                          style={{ imageRendering: 'pixelated' }}
                        />
                      </div>
                      <h3 className="text-lg sm:text-xl font-bold text-green-800 mb-4">Mira</h3>
                      <p className="text-sm sm:text-base text-gray-700 mb-6 leading-relaxed">
                        {npcDialogue}
                      </p>
                      <button
                        onClick={() => setShowNPCDialogue(false)}
                        className="bg-green-500 hover:bg-green-600 active:bg-green-700 text-white px-6 py-3 rounded-lg transition-colors touch-manipulation text-base min-h-[50px]"
                      >
                        Close
                      </button>
                    </div>
                  </div>
                </div>
              )}

              {/* Building Entry Modal */}
              {showBuildingModal && selectedBuilding && (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
                  <div className="bg-white p-6 rounded-xl border-4 border-blue-600 max-w-sm w-full shadow-2xl">
                    <div className="text-center">
                      <div className="mb-4">
                        <img
                          src={selectedBuilding.src}
                          alt="Building"
                          className="w-20 h-20 mx-auto object-contain"
                          style={{ imageRendering: 'pixelated' }}
                        />
                      </div>
                      <h3 className="text-xl font-bold text-blue-800 mb-4">Enter Building?</h3>
                      <p className="text-gray-700 mb-6">
                        Would you like to enter this building?
                      </p>
                      <div className="flex gap-3 justify-center">
                        <button
                          onClick={() => setShowBuildingModal(false)}
                          className="bg-gray-500 hover:bg-gray-600 active:bg-gray-700 text-white px-6 py-3 rounded-lg transition-colors touch-manipulation text-base min-h-[50px] min-w-[80px]"
                        >
                          No
                        </button>
                        <button
                          onClick={confirmEnterBuilding}
                          className="bg-blue-500 hover:bg-blue-600 active:bg-blue-700 text-white px-6 py-3 rounded-lg transition-colors touch-manipulation text-base min-h-[50px] min-w-[80px]"
                        >
                          Yes
                        </button>
                      </div>
                    </div>
                  </div>
                </div>
              )}

              {/* Modal Overlay for Battle States */}
              {(gameState === 'battling' || gameState === 'countdown' || gameState === 'revealing' || battleResult) && (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
                  <div className="bg-white p-4 sm:p-8 rounded-xl border-4 border-green-600 max-w-sm sm:max-w-md w-full shadow-2xl max-h-[80vh] overflow-y-auto">
                    
                    {/* Battle Interface */}
                    {gameState === 'battling' && (
                      <>
                        <div className="text-center mb-4 sm:mb-6">
                          <h2 className="text-2xl sm:text-3xl font-bold text-green-800 mb-2">
                            Challenge {selectedCreature?.name}!
                          </h2>
                          {!battleOptionsReady ? (
                            <p className="text-green-700 text-base sm:text-lg">Get ready...</p>
                          ) : (
                            <p className="text-green-700 text-base sm:text-lg">Choose your move:</p>
                          )}
                        </div>
                        {battleOptionsReady && (
                          <div className="flex flex-col gap-3">
                            {Object.entries(MOVES).map(([key, emoji]) => (
                              <button
                                key={key}
                                onClick={() => handlePlayerMove(key)}
                                className="bg-green-500 hover:bg-green-600 active:bg-green-700 text-white px-4 sm:px-6 py-4 sm:py-4 rounded-lg text-xl sm:text-2xl transition-colors flex items-center justify-center gap-3 hover:scale-105 transform touch-manipulation min-h-[60px] sm:min-h-[70px]"
                              >
                                <span className="text-2xl sm:text-3xl">{emoji}</span>
                                <span className="text-lg sm:text-xl">{MOVE_NAMES[key]}</span>
                              </button>
                            ))}
                          </div>
                        )}
                      </>
                    )}

                    {/* Countdown */}
                    {gameState === 'countdown' && (
                      <div className="text-center">
                        <div className="text-8xl font-bold text-green-800 animate-pulse mb-4">
                          {countdown > 0 ? countdown : 'GO!'}
                        </div>
                        <p className="text-green-600 text-lg">Get ready...</p>
                      </div>
                    )}

                    {/* Battle Result */}
                    {(gameState === 'revealing' || battleResult) && (
                      <div className="text-center">
                        <div className="flex justify-center gap-8 mb-6">
                          <div className="text-center">
                            <div className="text-lg font-bold text-blue-800 mb-2">You</div>
                            <div className="text-5xl mb-2">{MOVES[playerMove]}</div>
                            <div className="text-sm text-gray-600">{MOVE_NAMES[playerMove]}</div>
                          </div>
                          <div className="text-4xl self-center text-gray-500">VS</div>
                          <div className="text-center">
                            <div className="text-lg font-bold text-red-800 mb-2">
                              {selectedCreature?.rarity === 'rare' && typeof selectedCreature?.src === 'string' && selectedCreature?.src.includes('ü¶Ñ') ? (
                                selectedCreature?.src
                              ) : (
                                <img
                                  src={selectedCreature?.src}
                                  alt={selectedCreature?.name}
                                  className="w-16 h-16 mx-auto object-contain"
                                  style={{ imageRendering: 'pixelated' }}
                                />
                              )}
                            </div>
                            <div className="text-5xl mb-2">{MOVES[creatureMove]}</div>
                            <div className="text-sm text-gray-600">{MOVE_NAMES[creatureMove]}</div>
                          </div>
                        </div>
                        
                        {battleResult && (
                          <div className="text-2xl font-bold">
                            {battleResult === 'player' && (
                              <div className="text-green-600">
                                üéâ You Win! üéâ
                                {currentBattleWins >= 3 ? (
                                  <div className="text-lg text-purple-600 mt-3 p-3 bg-purple-100 rounded-lg">
                                    <div className="text-2xl mb-1">üéä RECRUITED! üéä</div>
                                    <div>{selectedCreature?.name} joins your party!</div>
                                  </div>
                                ) : (
                                  <div className="text-base text-gray-600 mt-2 bg-gray-100 p-2 rounded">
                                    Progress: {currentBattleWins}/3 wins to recruit
                                  </div>
                                )}
                              </div>
                            )}
                            {battleResult === 'creature' && (
                              <div className="text-red-600">
                                üí• You Lose! üí•
                                <div className="text-sm text-gray-600 mt-2">Try again next time!</div>
                              </div>
                            )}
                            {battleResult === 'tie' && (
                              <div className="text-yellow-600">
                                ü§ù It's a Tie! ü§ù
                                <div className="text-sm text-gray-600 mt-2">Great minds think alike!</div>
                              </div>
                            )}
                          </div>
                        )}
                      </div>
                    )}

                  </div>
                </div>
              )}

              {/* Reset Button - Mobile Friendly */}
              <div className="mt-4 text-center">
                <button
                  onClick={resetGame}
                  className="bg-red-500 hover:bg-red-600 active:bg-red-700 text-white px-6 py-3 rounded-lg transition-colors touch-manipulation text-lg min-h-[50px]"
                >
                  Reset Game
                </button>
              </div>

              {/* Instructions - Mobile Responsive */}
              <div className="mt-4 bg-white p-3 sm:p-4 rounded-lg border border-green-600 mx-2 sm:mx-0">
                <h3 className="font-bold text-green-800 mb-2 text-sm sm:text-base">How to Play:</h3>
                <ul className="text-xs sm:text-sm text-green-700 space-y-1">
                  {isMobile ? (
                    <>
                      <li>‚Ä¢ Touch and drag anywhere on screen to move Zoe</li>
                      <li>‚Ä¢ Tap directly on any creature to challenge them to battle</li>
                      <li>‚Ä¢ Win 3 battles against a creature to recruit it</li>
                    </>
                  ) : (
                    <>
                      <li>‚Ä¢ Move Zoe with WASD or arrow keys</li>
                      <li>‚Ä¢ Get close to creatures and press SPACE to challenge them</li>
                      <li>‚Ä¢ Win 3 battles against a creature to recruit it to your party</li>
                    </>
                  )}
                  <li>‚Ä¢ Recruited creatures will follow you around</li>
                  <li>‚Ä¢ üçç‚Üíüçë üçë‚Üíüî™ üî™‚Üíüçç</li>
                </ul>
              </div>
            </div>
          );
        }

        const { createRoot } = ReactDOM;
        const root = createRoot(document.getElementById('root'));
        root.render(<PineappleKnifeBumGame />);
    </script>
</body>
</html>